@0xe7603b9ac00e2251;

using import "common.capnp".Signature;
using import "common.capnp".PublicKey;
using import "common.capnp".RandNonce;
using import "common.capnp".InvoiceId;
using import "common.capnp".Uid;
using import "common.capnp".CustomUInt128;
using import "common.capnp".CustomInt128;
using import "common.capnp".RelayAddress;
using import "common.capnp".HashedLock;
using import "common.capnp".PlainLock;
using import "common.capnp".Hash;


# Token channel messages
# ----------------------

struct MoveToken {
        operations @0: List(FriendOperation);
        # Ordered batched operations for this move token.
        # First operation should be applied first.
        optLocalRelays: union {
                empty @1: Void;
                relays @2: List(RelayAddress);
        }
        oldToken @3: Signature;
        # Token of the previous move token. This is a proof that we have
        # received the previous message before sending this one.
        localPublicKey @4: PublicKey;
        # Public key of the sender of this message
        # Having this information here is useful if this message is later presented as a proof
        # of communication between the two sides.
        remotePublicKey @5: PublicKey;
        # Public key of the receiver of this message
        # Having this information here is useful if this message is later presented as a proof
        # of communication between the two sides.
        inconsistencyCounter @6: UInt64;
        # Amount of inconsistencies that have occurred so far. Begins from 0,
        # and increases every time an inconsistency was resolved.
        moveTokenCounter @7: CustomUInt128;
        # Amount of MoveToken messages in this token channel. Begins from 0,
        # and increases every time a MoveToken message increases. This number
        # is shared for both sides of the token channel.
        balance @8 : CustomInt128;
        # Balance between the two parties in the token channel. This number could be
        # deduced by each of the parties only by looking at the operations
        # field. We put the balance here to make sure it is signed by the
        # sending party, allowing the receiving party to use
        # this MoveToken as a proof later.
        # Note that the balance here is represented from the point of view of the sender.
        # The receiver will have to negate this value.
        localPendingDebt @9: CustomUInt128;
        # The current local pending debt from the point of view of the sender.
        remotePendingDebt @10: CustomUInt128;
        # The current remote pending debt from the point of view of the sender.
        randNonce @11: RandNonce;
        # A random nonce, generated by the sender. We have it because the
        # sender is signing over this message, and we don't want him to be
        # tricked into signing over something strange.
        newToken @12 : Signature;
        # A signature over all the previous fields.
}

struct MoveTokenRequest {
        moveToken @0: MoveToken;
        tokenWanted @1: Bool;
}

struct InconsistencyError {
        resetToken @0: Signature;
        inconsistencyCounter @1: UInt64;
        balanceForReset @2: CustomInt128;
}


# A messages sent between friends.
struct FriendMessage {
        union {
                moveTokenRequest @0: MoveTokenRequest;
                inconsistencyError @1: InconsistencyError;
        }
}




# Token Operations
# ------------------

# Set the maximum possible debt for the remote party.
# Note: It is not possible to set a maximum debt smaller than the current debt
# This will cause an inconsistency.
# struct SetRemoteMaxDebtOp {
#         remoteMaxDebt @0: CustomUInt128;
# }

struct FriendsRoute {
        publicKeys @0: List(PublicKey);
        # A list of public keys
}

# A custom type for a rational 128 bit number.
struct Ratio128 {
        union {
                one @0: Void;
                numerator @1: CustomUInt128;
        }
}


struct RequestSendFundsOp {
        requestId @0: Uid;
        # Id number of this request. Used to identify the whole transaction
        # over this route.
        srcHashedLock @1: HashedLock;
        # A hash lock created by the originator of this request
        route @2: FriendsRoute;
        destPayment @3: CustomUInt128;
        totalDestPayment @4: CustomUInt128;
        invoiceId @5: InvoiceId;
        # Id number of the invoice we are attempting to pay
        leftFees @6: CustomUInt128;
        # Amount of fees left to give to mediators
        # Every mediator takes the amount of fees he wants and subtracts this
        # value accordingly.
}

struct ResponseSendFundsOp {
        requestId @0: Uid;
        destHashedLock @1: HashedLock;
        randNonce @2: RandNonce;
        signature @3: Signature;
        # Signature{key=destinationKey}(
        #   sha512/256("FUNDS_RESPONSE") ||
        #   sha512/256(requestId || sha512/256(route) || randNonce) ||
        #   srcHashedLock || 
        #   destHashedLock || 
        #   destPayment ||
        #   totalDestPayment ||
        #   invoiceId
        # )
        #
        # Note that the signature contains an inner blob (requestId || ...).
        # This is done to make the size of the receipt shorter.
        # See also the Receipt structure.
}

struct CancelSendFundsOp {
        requestId @0: Uid;
}

struct CollectSendFundsOp {
        requestId @0: Uid;
        srcPlainLock @1: PlainLock;
        destPlainLock @2: PlainLock;
}


struct FriendOperation {
        union {
                enableRequests @0: Void;
                disableRequests @1: Void;
                setRemoteMaxDebt @2: CustomUInt128;
                requestSendFunds @3: RequestSendFundsOp;
                responseSendFunds @4: ResponseSendFundsOp;
                cancelSendFunds @5: CancelSendFundsOp;
                collectSendFunds @6: CollectSendFundsOp;
        }
}

